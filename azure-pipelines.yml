# Example Azure DevOps pipeline with multiple examples embedded.

# The key concepts are explained here: https://learn.microsoft.com/azure/devops/pipelines/get-started/key-pipelines-concepts

# Using the default filename 'azure-pipelines.yml' will auto-register the pipeline in Azure DevOps.
# If you want to use a different filename, you will need to register the pipeline manually.

# When to run the pipeline.
trigger: 
- main

# Inputs from the UI, note parameters have types.
parameters:
- name: includeS1
  displayName: Include stage 1
  type: boolean
  default: true


# Set the default pool for all stages and jobs
pool:
  # Use MS-hosted agents: https://learn.microsoft.com/azure/devops/pipelines/agents/hosted  
  # Installed Software: https://github.com/actions/runner-images/blob/main/images/linux/Ubuntu2204-Readme.md
  vmImage: 'ubuntu-latest'  # other example: 'windows-latest'


variables:
- group: lookup-variables  # https://docs.microsoft.com/azure/devops/pipelines/library/variable-groups
- name: static-variable
  value: 'static value'
- name: runtime-variable
  value: $[variables['var1-in-group']] # from variable group
- name: compile-variable
  ${{ if parameters.includeS1 }}: 
    value: 'value-true'
  ${{ else }}:
    value: 'value-false'
- name: test-overwrite
  value: 'top level'
- name: azure_service_connection
  value: arm-example-conn



stages:
- stage: s1
  displayName: Variables (s1)
  condition: eq(${{ parameters.includeS1 }}, true)

  variables:
  - name: test-overwrite
    value: 'stage level'

  jobs:
  - job: j1
    displayName: Predefined Variables
    # https://learn.microsoft.com/azure/devops/pipelines/build/variables
    steps:
    - checkout: none  # skip checkout
    - script: |
        echo "Pipeline.Workspace: $(Pipeline.Workspace) (same as Agent.BuildDirectory)"
        echo "Agent.HomeDirectory: $(Agent.HomeDirectory)"
        echo "Agent.OS: $(Agent.OS)"
        echo "AGENT_JOBSTATUS: $AGENT_JOBSTATUS"
        echo "Agent.TempDirectory: $(Agent.TempDirectory) (cleaned after each job)"
      displayName: Agent variables
    
    - script: |
        echo "Build.ArtifactStagingDirectory: $(Build.ArtifactStagingDirectory)"
        echo "Build.BuildId: $(Build.BuildId)"
        echo "Build.Reason: $(Build.Reason)"
        echo "Build.SourceBranch: $(Build.SourceBranch)"
        echo "Build.SourceBranchName: $(Build.SourceBranchName)"
        echo "Note: a branch /feature/sneaky/main is also called main!"
      displayName: Build variables (not in template)

    - template: templates/steps-print-build-variables.yml
  
  - job: j2
    displayName: User-defined variables
    
    variables:
    - name: test-overwrite
      value: 'j2 level'

    steps:
    - checkout: none  # skip checkout
    - script: |
        echo "User-defined variables:"
        echo "  static-variable: $(static-variable)"
        echo "  runtime-variable (from the group): $(runtime-variable)"
        echo "  compile-variable: $(compile-variable)"
        echo "  test-overwrite: $(test-overwrite)"
      displayName: User-defined variables

  - job: j3
    displayName: Set variables (j3)
    steps:
    - checkout: none  # skip checkout
    - script: |
        # Note: task 'name' is required for referencing output variables in other jobs!.

        echo "##vso[task.setvariable variable=var1_no_output]this is usable ONLY in this Job!"
        echo "##vso[task.setvariable variable=var2_is_output;isOutput=true]This can by used in all jobs that dependsOn this stage!"
        echo "##vso[task.setvariable variable=var3_no_output_is_secret;iSsecret=true]this is never shown in the logs!"
        echo "##vso[task.setvariable variable=var4_no_output_is_readonly;isreadonly=true]this value is immutable."
        
        # After this task the variables are available:
        echo "$(var1_no_output)" # no output.
      name: task_vars
      displayName: Set variables

    - script: echo "##vso[task.setvariable variable=var4_no_output_is_readonly]or was it mutable?."
      displayName: Try to update readonly
      failOnStderr: false
      continueOnError: true
    
    - task: PythonScript@0
      displayName: Python variable
      inputs:
        script: |
          print('Output variables can be created inside Pyhton code:')
          print('##vso[task.setvariable variable=var5_python]Created inside Python')

    - script: |
        echo "How to reference variables:"
        echo "  var1: $(var1_no_output)"
        echo "  var2: $(var2_is_output)            (incorrect: because incorrect reference)"
        echo "  var2: $(task_vars.var2_is_output)  (correct: including task.name, required because isOutput=true)"
        echo "  var3: $(var3_no_output_is_secret)"
        echo "  var4: $(var4_no_output_is_readonly)"
        echo "  var5: $(var5_python)"
      displayName: Show vars (same job)


  - deployment: d1
    displayName: Set variables (d1)
    environment: 'example-env1'
    strategy:
      runOnce:
        deploy:
          steps:
          - script: |
              echo "##vso[task.setvariable variable=var6;isOutput=true]Created inside a type-Deployment"
              echo "Created output variable 'var6' in a deployment, this is referenced differently!"
            name: task_vars
            displayName: Set variable (deployment)

  - job: j4
    displayName: Get Variabled (dependsOn j3)
    dependsOn: j3   # dependsOn is required to get output variables from other jobs.

    variables:
      - name: var1_no_output  # note: isOutput=false, therefor this is an empty variable.
        value: $[ dependencies.j3.outputs['task_vars.var1_no_output'] ]
      - name: var2_is_output
        value: $[ dependencies.j3.outputs['task_vars.var2_is_output'] ]
      - name: var6
        value: $[ dependencies.d1.outputs['task_vars.var6'] ]

    steps:
      - checkout: none  # skip checkout
      - script: |
          echo "  var1_no_output: $(var1_no_output)  (empty because isOutput=false)"
          echo "  var2_is_output: $(var2_is_output)"
          echo "  var6: $(var2_is_output)   (from deployment)"
        displayName: Show vars (future job)



- stage: s1b
  displayName: Get Variables (s1b)
  dependsOn: s1

  variables:
    # For jobs: stageDependencies.[STAGE].[JOB].outputs['[TASK].[VAR]']
    job_variable: $[stageDependencies.s1.j3.outputs['task_vars.var2_is_output']]
    # Note: deployment reference repead the name (d1)!
    #   stageDependencies.[STAGE].[DEPLOYMENT].outputs['[DEPLOYMENT].[TASK].[VAR]']
    deployment_var: $[stageDependencies.s1.d1.outputs['d1.task_vars.var6']]

  jobs:
  - job: j1
    displayName: Get Variables (s1.j3)
    steps:
      - checkout: none  # skip checkout
      - script: |
          echo "job_variable: $(job_variable)"
          echo "deployment_var: $(deployment_var)"
        displayName: Show vars (future stage)

- stage: s2a
  displayName: Artifacts (s2a)
  dependsOn: []  # start immediately
  jobs:
  - job: j1
    displayName: Create actifact
    condition: false # skipped: issue with uploading the artifact to https://vsblobprodsu6weu.vsblob.visualstudio.com.
    steps:
    # Pipeline artifacts have to be unique.
    # To support restartability, make the name unique each run.
    - script: |
        name="artifact1#$(System.JobAttempt)-$(Build.BuildId)"
        echo "##vso[task.setvariable variable=value;isOutput=true]$name"
        echo "created variable 'value=$name'"
      name: set_artifact_name
      displayName: Unique artifact
    
    - task: CopyFiles@2
      displayName: 'Copy Files to: $(Build.ArtifactStagingDirectory)'
      inputs:
        contents: 'README.md'
        targetFolder: $(Build.ArtifactStagingDirectory)

    - publish: $(Build.ArtifactStagingDirectory)
      artifact: $(set_artifact_name.value)
      displayName: Publish artifact

- stage: s2b
  displayName: Job-types (s2b)

  jobs:
  - job: j1
    displayName: Type-Job
    steps:
    # Jobs checkout source-code of the selected branch by default.
    # Jobs do not download pipline artifacts by default.
    
    # Note: restarting a job will point to the same commit in the branch!
    - script: echo 'Jobs checkout code' && ls -lr .
      displayName: 'Run a one-line script'

  - deployment: d2
    displayName: Type-Deployment
    
    variables:
      artifact_name: $[stageDependencies.s2a.j1.outputs['set_artifact_name.value']]

    # Type: Deployment is tighly coupled to an environment, defined as a string.
    # Although it a string, but is linked to a Pipeline Environment.
    # Configure the enviroment to:
    # - Approvals: Single or multiple groups/individuals who all must approve. (no order, nr of people)
    # - Branch Control: Limit access to specific branches (e.g. only from main/release) optionally check for Branch Policy.
    # - Exclusive Lock: block concurrent Stages in any other pipeline with a deployment to the same environment.
    # - Business Hours: Limit access within specified timeframe.
    environment: 'example-env1'
    strategy:
      runOnce:
        deploy:
          steps:
          # Deployments do NOT checkout code.
          # Deployments download (all) pipeline artifacts by default.
          - script: |
              echo "actifact_name: $(artifact_name)"
              ls -lr $(Pipeline.Workspace)



# In this stage we use a server pool, which is a pool of agents that are not hosted by Microsoft.
# Some tasks require the pool: server, more info 
# https://learn.microsoft.com/azure/devops/pipelines/process/phases?view=azure-devops&tabs=yaml#agentless-tasks
- stage: s3
  displayName: Agentless (s3)
  dependsOn: []  # start immediately

  pool: server 

  jobs:
  - job: j1
    displayName: No agent tasks
    steps:
    - task: Delay@1
      displayName: 'Delay 1 minute'
      inputs:
        delayForMinutes: '1'
    
    - task: ManualValidation@0
      timeoutInMinutes: 1
      inputs:
        notifyUsers: '' # [orgname]\group name
        instructions: 'This text describes actions for users, to decide: resume or reject, not this is NOT safe-guard. Because enyone can approve. For a blocking-approval you must use an Environment with approvals & checks!'
        onTimeout: 'resume' # Default: reject.


- stage: s4
  displayName: Git (s4)
  dependsOn: []  # start immediately

  jobs:
  - job: j1
    displayName: Update README
    steps:
    - checkout: self
      persistCredentials: true  # allow push
      fetchDepth: 0  # fetch all commits and branches
      # https://learn.microsoft.com/azure/devops/pipelines/yaml-schema/steps-checkout?view=azure-pipelines#shallow-fetch

    - script: |
        set -e
        git checkout $(Build.SourceBranchName)
        git config --global user.email "no-reply@azure-devops.com"
        git config --global user.name "Azure DevOps"
      displayName: 'Git config'
      
    - script: sed -Ei 's/(Auto-update by pipeline:).*/\1 last buildId $(Build.BuildId)/g' README.md
      displayName: Set buildId README

    # Note: [skip-ci] in the commit message will prevent a new build to be triggered.
    - script: | 
        git add README.md
        git commit -m "DevOps: update readme [skip ci]" 
        git push
      displayName: 'Git commit and push'

- stage: s5
  displayName: Azure CLI (s5)
  dependsOn: [] # start immediately

  jobs:
  - job: j1
    displayName: show account
    steps:
    - task: AzureCLI@2
      displayName: 'Azure CLI (default)'
      inputs:
        azureSubscription: $(azure_service_connection)
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          echo "What are the subscription this ServiceConnection have access to?"
          az account show -o table